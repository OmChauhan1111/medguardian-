# db.py  -- MongoDB replacement for your MySQL-based db.py
import os
import json
import bcrypt
from typing import List, Dict, Any
from datetime import datetime
from bson.objectid import ObjectId

# Try to read MONGO_URI and DB name from Streamlit secrets first, then env vars
MONGO_URI = None
MONGO_DB_NAME = None
try:
    import streamlit as st
    MONGO_URI = st.secrets.get("MONGO_URI") or os.environ.get("MONGO_URI")
    MONGO_DB_NAME = st.secrets.get("MONGO_DB_NAME") or os.environ.get("MONGO_DB_NAME") or "medguardian"
except Exception:
    MONGO_URI = os.environ.get("MONGO_URI")
    MONGO_DB_NAME = os.environ.get("MONGO_DB_NAME") or "medguardian"

if not MONGO_URI:
    raise RuntimeError("MONGO_URI not found. Add it to .streamlit/secrets.toml or environment variables.")

from pymongo import MongoClient, ASCENDING, DESCENDING

_client = MongoClient(MONGO_URI)
_db = _client[MONGO_DB_NAME]

_users = _db["users"]
_reports = _db["reports"]
_chats = _db["chats"]

# Create indexes (safe to call multiple times)
try:
    _users.create_index([("username", ASCENDING)], unique=True)
    _reports.create_index([("user_id", ASCENDING), ("created_at", DESCENDING)])
    _chats.create_index([("user_id", ASCENDING), ("created_at", ASCENDING)])
except Exception:
    pass

# ----- User functions -----
def create_user(username: str, password: str, full_name: str = None, phone: str = None) -> bool:
    """
    Returns True if user created, False if username exists or failure.
    """
    if not username or not password:
        return False
    username = username.strip().lower()
    if _users.find_one({"username": username}):
        return False
    pw_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()
    doc = {
        "username": username,
        "password_hash": pw_hash,
        "full_name": full_name,
        "phone": phone,
        "created_at": datetime.utcnow()
    }
    try:
        res = _users.insert_one(doc)
        return bool(res.inserted_id)
    except Exception:
        return False

def authenticate_user(username: str, password: str):
    """
    Returns {"id": <id>, "username": ..., "full_name": ...} on success, else None.
    Note: id will be a string (ObjectId).
    """
    if not username or not password:
        return None
    username = username.strip().lower()
    row = _users.find_one({"username": username})
    if not row:
        return None
    try:
        if bcrypt.checkpw(password.encode(), row["password_hash"].encode()):
            return {"id": str(row["_id"]), "username": row["username"], "full_name": row.get("full_name")}
    except Exception:
        return None
    return None

# ----- Report functions -----
def insert_report(user_id: Any, report: Dict[str, Any]):
    """
    Insert a report document. user_id can be numeric or string.
    Returns inserted document id (string).
    """
    try:
        uid = str(user_id)
        doc = {
            "user_id": uid,
            "patient_id": report.get("Patient ID"),
            "patient_name": report.get("Patient Name"),
            "phone": report.get("Phone"),
            "doctor_name": report.get("Doctor Name"),
            "referred_by": report.get("Referred By"),
            "sample_collected": report.get("Sample Collected"),
            "report_generated_by": report.get("Report Generated By"),
            "date": report.get("Date"),
            "condition_name": report.get("Condition"),
            "risk": float(report.get("Risk %", 0) or 0),
            "raw_json": json.dumps(report, default=str),
            "created_at": datetime.utcnow()
        }
        res = _reports.insert_one(doc)
        return str(res.inserted_id)
    except Exception as e:
        raise

def get_reports_for_user(user_id: Any, limit: int = 1000) -> List[Dict[str, Any]]:
    uid = str(user_id)
    rows = list(_reports.find({"user_id": uid}).sort("created_at", -1).limit(limit))
    out = []
    for r in rows:
        try:
            raw = json.loads(r.get("raw_json") or "{}")
        except Exception:
            raw = {}
        out.append({
            "id": str(r.get("_id")),
            "user_id": r.get("user_id"),
            "patient_id": r.get("patient_id"),
            "patient_name": r.get("patient_name"),
            "phone": r.get("phone"),
            "doctor_name": r.get("doctor_name"),
            "referred_by": r.get("referred_by"),
            "sample_collected": r.get("sample_collected"),
            "report_generated_by": r.get("report_generated_by"),
            "date": r.get("date"),
            "condition_name": r.get("condition_name"),
            "risk": r.get("risk"),
            "raw": raw
        })
    return out

def get_filtered_reports(user_id: Any, condition: str = None, patient_name: str = None):
    query = {"user_id": str(user_id)}
    if condition:
        query["condition_name"] = condition
    if patient_name:
        query["patient_name"] = patient_name
    rows = list(_reports.find(query).sort("created_at", -1))
    return rows

# ----- Delete report -----
def delete_report(report_id: str) -> bool:
    """
    Accepts the report id (string). Tries ObjectId conversion first.
    Returns True if deleted, False otherwise.
    """
    if not report_id:
        raise ValueError("delete_report called with empty report_id")
    try:
        res = _reports.delete_one({"_id": ObjectId(report_id)})
        return res.deleted_count > 0
    except Exception:
        res = _reports.delete_one({"_id": report_id})
        return res.deleted_count > 0

# ----- Chat functions -----
def insert_chat(user_id: Any, role: str, message: str):
    doc = {
        "user_id": str(user_id),
        "role": role,
        "message": message,
        "created_at": datetime.utcnow()
    }
    res = _chats.insert_one(doc)
    return str(res.inserted_id)

def get_chats_for_user(user_id: Any, limit: int = 500):
    uid = str(user_id)
    rows = list(_chats.find({"user_id": uid}).sort("created_at", 1).limit(limit))
    out = []
    for r in rows:
        out.append({
            "id": str(r.get("_id")),
            "user_id": r.get("user_id"),
            "role": r.get("role"),
            "message": r.get("message"),
            "created_at": r.get("created_at")
        })
    return out

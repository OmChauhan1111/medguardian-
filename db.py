# db.py  -- MongoDB + in-memory fallback (based on your original code)
import os
import json
import bcrypt
from typing import List, Dict, Any, Optional
from datetime import datetime

# ------------- CONFIG / SECRETS -------------
MONGO_URI: Optional[str] = None
MONGO_DB_NAME: Optional[str] = None

try:
    import streamlit as st

    MONGO_URI = st.secrets.get("MONGO_URI") or os.environ.get("MONGO_URI")
    MONGO_DB_NAME = (
        st.secrets.get("MONGO_DB_NAME") or os.environ.get("MONGO_DB_NAME") or "medguardian"
    )
except Exception:
    MONGO_URI = os.environ.get("MONGO_URI")
    MONGO_DB_NAME = os.environ.get("MONGO_DB_NAME") or "medguardian"

USE_DB = False

# In-memory storage structure
_mem = {
    "users": [],
    "reports": [],
    "chats": [],
    "user_id_counter": 1,
    "report_id_counter": 1,
    "chat_id_counter": 1,
}

# ------------- TRY MONGODB INIT -------------
if MONGO_URI:
    try:
        from pymongo import MongoClient, ASCENDING, DESCENDING
        from bson.objectid import ObjectId

        _client = MongoClient(MONGO_URI)
        _db = _client[MONGO_DB_NAME]

        _users = _db["users"]
        _reports = _db["reports"]
        _chats = _db["chats"]

        # Create indexes (safe to call multiple times)
        try:
            _users.create_index([("username", ASCENDING)], unique=True)
            _reports.create_index([("user_id", ASCENDING), ("created_at", DESCENDING)])
            _chats.create_index([("user_id", ASCENDING), ("created_at", ASCENDING)])
        except Exception:
            pass

        USE_DB = True
        print(f"[DB] Using MongoDB backend: {MONGO_DB_NAME}")
    except Exception as e:
        print("[DB] Mongo init failed, using in-memory fallback:", e)
        USE_DB = False
else:
    print("[DB] MONGO_URI not found â€” using in-memory fallback (no persistent DB).")
    USE_DB = False


# ------------- COMMON HELPERS -------------
def _hash_pw(password: str) -> str:
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()


def _check_pw(password: str, pw_hash: str) -> bool:
    try:
        return bcrypt.checkpw(password.encode(), pw_hash.encode())
    except Exception:
        return False


# ==========================
#    MONGODB IMPLEMENTATION
# ==========================
if USE_DB:
    # ----- User functions -----
    def create_user(
        username: str, password: str, full_name: str = None, phone: str = None
    ) -> bool:
        """
        Returns True if user created, False if username exists or failure.
        """
        if not username or not password:
            return False
        username = username.strip().lower()
        if _users.find_one({"username": username}):
            return False
        pw_hash = _hash_pw(password)
        doc = {
            "username": username,
            "password_hash": pw_hash,
            "full_name": full_name,
            "phone": phone,
            "created_at": datetime.utcnow(),
        }
        try:
            res = _users.insert_one(doc)
            return bool(res.inserted_id)
        except Exception:
            return False

    def authenticate_user(username: str, password: str):
        """
        Returns {"id": <id>, "username": ..., "full_name": ...} on success, else None.
        Note: id will be a string (ObjectId).
        """
        if not username or not password:
            return None
        username = username.strip().lower()
        row = _users.find_one({"username": username})
        if not row:
            return None
        try:
            if _check_pw(password, row["password_hash"]):
                return {
                    "id": str(row["_id"]),
                    "username": row["username"],
                    "full_name": row.get("full_name"),
                }
        except Exception:
            return None
        return None

    # ----- Report functions -----
    def insert_report(user_id: Any, report: Dict[str, Any]):
        """
        Insert a report document. user_id can be numeric or string.
        Returns inserted document id (string).
        """
        try:
            uid = str(user_id)
            doc = {
                "user_id": uid,
                "patient_id": report.get("Patient ID"),
                "patient_name": report.get("Patient Name"),
                "phone": report.get("Phone"),
                "doctor_name": report.get("Doctor Name"),
                "referred_by": report.get("Referred By"),
                "sample_collected": report.get("Sample Collected"),
                "report_generated_by": report.get("Report Generated By"),
                "date": report.get("Date"),
                "condition_name": report.get("Condition"),
                "risk": float(report.get("Risk %", 0) or 0),
                "raw_json": json.dumps(report, default=str),
                "created_at": datetime.utcnow(),
            }
            res = _reports.insert_one(doc)
            return str(res.inserted_id)
        except Exception as e:
            raise

    def get_reports_for_user(user_id: Any, limit: int = 1000) -> List[Dict[str, Any]]:
        uid = str(user_id)
        rows = list(_reports.find({"user_id": uid}).sort("created_at", -1).limit(limit))
        out = []
        for r in rows:
            try:
                raw = json.loads(r.get("raw_json") or "{}")
            except Exception:
                raw = {}
            out.append(
                {
                    "id": str(r.get("_id")),
                    "user_id": r.get("user_id"),
                    "patient_id": r.get("patient_id"),
                    "patient_name": r.get("patient_name"),
                    "phone": r.get("phone"),
                    "doctor_name": r.get("doctor_name"),
                    "referred_by": r.get("referred_by"),
                    "sample_collected": r.get("sample_collected"),
                    "report_generated_by": r.get("report_generated_by"),
                    "date": r.get("date"),
                    "condition_name": r.get("condition_name"),
                    "risk": r.get("risk"),
                    "raw": raw,
                }
            )
        return out

    def get_filtered_reports(user_id: Any, condition: str = None, patient_name: str = None):
        from bson.objectid import ObjectId  # only needed here

        query = {"user_id": str(user_id)}
        if condition:
            query["condition_name"] = condition
        if patient_name:
            query["patient_name"] = patient_name
        rows = list(_reports.find(query).sort("created_at", -1))
        return rows

    # ----- Delete report -----
    def delete_report(report_id: str) -> bool:
        """
        Accepts the report id (string). Tries ObjectId conversion first.
        Returns True if deleted, False otherwise.
        """
        from bson.objectid import ObjectId

        if not report_id:
            raise ValueError("delete_report called with empty report_id")
        try:
            res = _reports.delete_one({"_id": ObjectId(report_id)})
            return res.deleted_count > 0
        except Exception:
            res = _reports.delete_one({"_id": report_id})
            return res.deleted_count > 0

    # ----- Chat functions -----
    def insert_chat(user_id: Any, role: str, message: str):
        doc = {
            "user_id": str(user_id),
            "role": role,
            "message": message,
            "created_at": datetime.utcnow(),
        }
        res = _chats.insert_one(doc)
        return str(res.inserted_id)

    def get_chats_for_user(user_id: Any, limit: int = 500):
        uid = str(user_id)
        rows = list(_chats.find({"user_id": uid}).sort("created_at", 1).limit(limit))
        out = []
        for r in rows:
            out.append(
                {
                    "id": str(r.get("_id")),
                    "user_id": r.get("user_id"),
                    "role": r.get("role"),
                    "message": r.get("message"),
                    "created_at": r.get("created_at"),
                }
            )
        return out

# ==========================
#   IN-MEMORY IMPLEMENTATION
# ==========================
else:
    # NOTE: yahan data sirf RAM me rahega; server restart hote hi sab reset ho jayega.

    def _find_user(username: str) -> Optional[Dict[str, Any]]:
        u = username.strip().lower()
        for row in _mem["users"]:
            if row["username"] == u:
                return row
        return None

    # ----- User functions -----
    def create_user(
        username: str, password: str, full_name: str = None, phone: str = None
    ) -> bool:
        if not username or not password:
            return False
        if _find_user(username):
            return False
        uid = str(_mem["user_id_counter"])
        _mem["user_id_counter"] += 1
        pw_hash = _hash_pw(password)
        _mem["users"].append(
            {
                "id": uid,
                "username": username.strip().lower(),
                "password_hash": pw_hash,
                "full_name": full_name,
                "phone": phone,
                "created_at": datetime.utcnow(),
            }
        )
        return True

    def authenticate_user(username: str, password: str):
        if not username or not password:
            return None
        row = _find_user(username)
        if not row:
            return None
        if _check_pw(password, row["password_hash"]):
            return {
                "id": row["id"],
                "username": row["username"],
                "full_name": row.get("full_name"),
            }
        return None

    # ----- Report functions -----
    def insert_report(user_id: Any, report: Dict[str, Any]):
        rid = str(_mem["report_id_counter"])
        _mem["report_id_counter"] += 1
        _mem["reports"].append(
            {
                "id": rid,
                "user_id": str(user_id),
                "patient_id": report.get("Patient ID"),
                "patient_name": report.get("Patient Name"),
                "phone": report.get("Phone"),
                "doctor_name": report.get("Doctor Name"),
                "referred_by": report.get("Referred By"),
                "sample_collected": report.get("Sample Collected"),
                "report_generated_by": report.get("Report Generated By"),
                "date": report.get("Date"),
                "condition_name": report.get("Condition"),
                "risk": float(report.get("Risk %", 0) or 0),
                "raw": dict(report),
                "created_at": datetime.utcnow(),
            }
        )
        return rid

    def get_reports_for_user(user_id: Any, limit: int = 1000) -> List[Dict[str, Any]]:
        uid = str(user_id)
        rows = [r for r in _mem["reports"] if r["user_id"] == uid]
        rows.sort(key=lambda x: x["created_at"], reverse=True)
        out: List[Dict[str, Any]] = []
        for r in rows[:limit]:
            out.append(
                {
                    "id": r["id"],
                    "user_id": r["user_id"],
                    "patient_id": r.get("patient_id"),
                    "patient_name": r.get("patient_name"),
                    "phone": r.get("phone"),
                    "doctor_name": r.get("doctor_name"),
                    "referred_by": r.get("referred_by"),
                    "sample_collected": r.get("sample_collected"),
                    "report_generated_by": r.get("report_generated_by"),
                    "date": r.get("date"),
                    "condition_name": r.get("condition_name"),
                    "risk": r.get("risk"),
                    "raw": r.get("raw") or {},
                }
            )
        return out

    def get_filtered_reports(user_id: Any, condition: str = None, patient_name: str = None):
        uid = str(user_id)
        rows = [r for r in _mem["reports"] if r["user_id"] == uid]
        if condition:
            rows = [r for r in rows if r.get("condition_name") == condition]
        if patient_name:
            rows = [r for r in rows if r.get("patient_name") == patient_name]
        rows.sort(key=lambda x: x["created_at"], reverse=True)
        return rows

    # ----- Delete report -----
    def delete_report(report_id: str) -> bool:
        if not report_id:
            return False
        before = len(_mem["reports"])
        _mem["reports"] = [r for r in _mem["reports"] if r["id"] != report_id]
        return len(_mem["reports"]) < before

    # ----- Chat functions -----
    def insert_chat(user_id: Any, role: str, message: str):
        cid = str(_mem["chat_id_counter"])
        _mem["chat_id_counter"] += 1
        _mem["chats"].append(
            {
                "id": cid,
                "user_id": str(user_id),
                "role": role,
                "message": message,
                "created_at": datetime.utcnow(),
            }
        )
        return cid

    def get_chats_for_user(user_id: Any, limit: int = 500):
        uid = str(user_id)
        rows = [c for c in _mem["chats"] if c["user_id"] == uid]
        rows.sort(key=lambda x: x["created_at"])
        return rows[-limit:]
